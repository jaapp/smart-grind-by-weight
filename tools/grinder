#!/bin/bash
# Unified Grinder Tool
# Single script for all grinder operations: build, upload, export, analyze, report

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Platform detection for venv paths
if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]] && [[ ! -f /proc/version || ! $(grep -q Microsoft /proc/version 2>/dev/null) ]]; then
    # Windows (Git Bash, MSYS2, Cygwin) - but not WSL
    VENV_PYTHON="$SCRIPT_DIR/venv/Scripts/python.exe"
    VENV_PIP="$SCRIPT_DIR/venv/Scripts/pip.exe"
    VENV_STREAMLIT="$SCRIPT_DIR/venv/Scripts/streamlit.exe"
else
    # Unix-like (Linux, macOS, WSL)
    VENV_PYTHON="$SCRIPT_DIR/venv/bin/python3"
    VENV_PIP="$SCRIPT_DIR/venv/bin/pip"
    VENV_STREAMLIT="$SCRIPT_DIR/venv/bin/streamlit"
fi

BLE_TOOL="$SCRIPT_DIR/ble/grinder-ble.py"
STREAMLIT_DIR="$SCRIPT_DIR/streamlit-reports"
DB_PATH="$SCRIPT_DIR/database/grinder_data.db"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    echo -e "${BLUE}━━━ $1 ━━━${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_info() {
    echo -e "${CYAN}ℹ️  $1${NC}"
}

check_venv() {
    if [[ ! -f "$VENV_PYTHON" ]]; then
        print_warning "Virtual environment not found, setting up automatically..."
        cmd_install_quiet
    fi
}

cmd_install_quiet() {
    if [[ ! -d "$SCRIPT_DIR/venv" ]]; then
        print_info "Creating virtual environment..."
        # Try python3 first, fallback to python (Windows often uses 'python')
        if command -v python3 >/dev/null 2>&1; then
            python3 -m venv "$SCRIPT_DIR/venv"
        elif command -v python >/dev/null 2>&1; then
            python -m venv "$SCRIPT_DIR/venv"
        else
            print_error "Python not found. Please install Python 3.8+"
            exit 1
        fi
    fi
    
    print_info "Installing Python packages..."
    if [[ ! -f "$VENV_PIP" ]]; then
        print_error "Virtual environment pip not found at: $VENV_PIP"
        print_info "Platform: $OSTYPE, Expected venv structure may be incorrect"
        exit 1
    fi
    "$VENV_PIP" install -q -r "$SCRIPT_DIR/requirements.txt"
}

show_usage() {
    cat << EOF
${BLUE}Unified Grinder Tool${NC} - All-in-one grinder operations

${YELLOW}Usage:${NC} $0 <command> [options]

${YELLOW}Build & Upload Commands:${NC}
  build                 Build firmware using PlatformIO
  flash [port]          Build and flash firmware via USB
                       (auto-detects port if not specified)
  upload [firmware]     Upload firmware via BLE OTA
                       (finds latest .bin if no firmware specified)
  build-upload         Build firmware and upload via BLE

${YELLOW}Data & Analysis Commands:${NC}  
  export               Export grind data from device to database
  analyze              Export data and launch Streamlit report
  report               Launch Streamlit report (no data export)
  analyze-offline      Alias for 'report' - uses existing database

${YELLOW}BLE Commands:${NC}
  scan                 Scan for BLE devices
  connect              Connect to grinder device
  debug                Stream live debug logs from device
  info                 Get comprehensive device system information

${YELLOW}Development Commands:${NC}
  install              Manually install Python dependencies (auto-setup when needed)
  monitor              Monitor live debug output via BLE
  clean                Clean build artifacts

${YELLOW}Common Options:${NC}
  --db <file>          Specify database file (default: grinder_data.db)
  --device <name>      Specify device name (default: GrindByWeight)  
  --firmware <path>    Specify firmware file path
  --force-full         Force full firmware update (skip delta patching)
  --help, -h           Show this help message

${YELLOW}Examples:${NC}
  $0 flash                     # Build and flash via USB (auto-detect port)
  $0 flash /dev/cu.usbmodem14301 # Build and flash via specific USB port
  $0 build-upload              # Build and upload firmware
  $0 build-upload --force-full # Build and force full firmware update
  $0 analyze                   # Export data and show interactive report
  $0 report                    # Just show report from existing data
  $0 export --db session1.db  # Export to custom database
  $0 upload --device MyGrinder # Upload to specific device
  $0 connect                   # Connect to grinder device
  $0 info                      # Get device system information
EOF
}

# Helper function to detect ESP32 USB port
detect_usb_port() {
    local port
    port=$("$VENV_PYTHON" -m platformio device list | grep -A3 "USB.*303A:1001" | grep "^/" | head -1)
    if [[ -n "$port" ]]; then
        echo "$port"
        return 0
    fi

    # Fallback: look for any ESP32-like device
    port=$("$VENV_PYTHON" -m platformio device list | grep -E "^/dev/(cu\.usbmodem|ttyUSB|ttyACM)" | head -1)
    if [[ -n "$port" ]]; then
        echo "$port"
        return 0
    fi

    return 1
}

# Command implementations
cmd_build() {
    print_header "Building Firmware"
    check_venv
    cd "$PROJECT_DIR"
    # Use PlatformIO from the project venv to avoid global `pio` differences
    "$VENV_PYTHON" -m platformio run -e waveshare-esp32s3-touch-amoled-164
    print_success "Firmware build completed"
}

cmd_flash() {
    local port="$1"

    if [[ -z "$port" ]]; then
        print_info "Auto-detecting USB port..."
        port=$(detect_usb_port)
        if [[ -z "$port" ]]; then
            print_error "No ESP32 device found on USB"
            print_info "Please connect your ESP32 device and try again"
            print_info "Or specify port manually: $0 flash /dev/cu.usbmodem14301"
            exit 1
        fi
        print_info "Detected ESP32 at: $port"
    fi

    print_header "Building and Flashing Firmware via USB"
    check_venv
    cd "$PROJECT_DIR"
    # Use PlatformIO from the project venv to build and upload via USB
    "$VENV_PYTHON" -m platformio run -e waveshare-esp32s3-touch-amoled-164 --target upload --upload-port "$port"
    print_success "Firmware flashed successfully"
}

cmd_upload() {
    local firmware_path="$1"
    
    if [[ -z "$firmware_path" ]]; then
        print_info "Finding latest firmware file..."
        firmware_path=$(find "$PROJECT_DIR/.pio/build/" -name "*.bin" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
        
        if [[ -z "$firmware_path" ]]; then
            print_error "No firmware file found"
            print_info "Run: $0 build"
            exit 1
        fi
    fi
    
    print_header "BLE OTA Upload"
    print_info "Using firmware: $firmware_path"
    check_venv
    "$VENV_PYTHON" "$BLE_TOOL" upload "$firmware_path" "${@:2}"
}

cmd_build_upload() {
    cmd_build
    cmd_upload "$@"
}

cmd_export() {
    print_header "Exporting Grind Data"
    check_venv
    "$VENV_PYTHON" "$BLE_TOOL" export "$@"
}

cmd_analyze() {
    print_header "Data Analysis Workflow"
    check_venv
    "$VENV_PYTHON" "$BLE_TOOL" analyse "$@"
}

cmd_report() {
    print_header "Launching Streamlit Report"
    
    # Check if database exists
    local db_file="$DB_PATH"
    if [[ "$1" == "--db" && -n "$2" ]]; then
        if [[ "$2" == /* ]]; then
            # Absolute path provided
            db_file="$2"
        else
            # Relative path, put in database directory
            db_file="$SCRIPT_DIR/database/$2"
        fi
    fi
    
    if [[ ! -f "$db_file" ]]; then
        print_error "Database file not found: $db_file"
        print_info "Run: $0 export"
        exit 1
    fi
    
    # Check if streamlit exists in venv
    if [[ ! -f "$VENV_STREAMLIT" ]]; then
        print_warning "Streamlit not found, installing..."
        "$VENV_PIP" install streamlit>=1.28.0 plotly>=5.15.0
    fi
    
    print_info "Using database: $db_file"
    print_info "Opening at: http://localhost:8501"
    print_info "Press Ctrl+C to stop the server"
    
    # Launch streamlit with proper environment
    cd "$STREAMLIT_DIR"
    GRIND_DB_PATH="$db_file" PYTHONPATH="$STREAMLIT_DIR" "$VENV_PYTHON" -m streamlit run grind_report.py
}

cmd_analyze_offline() {
    cmd_report "$@"
}

cmd_scan() {
    print_header "Scanning for BLE Devices"
    check_venv
    "$VENV_PYTHON" "$BLE_TOOL" scan "$@"
}

cmd_connect() {
    print_header "Connecting to Grinder"
    check_venv
    "$VENV_PYTHON" "$BLE_TOOL" connect "$@"
}

cmd_debug() {
    print_header "Debug Monitor"
    check_venv
    "$VENV_PYTHON" "$BLE_TOOL" debug "$@"
}

cmd_info() {
    print_header "Device System Information"
    check_venv
    "$VENV_PYTHON" "$BLE_TOOL" info "$@"
}

cmd_install() {
    print_header "Installing Dependencies"
    cmd_install_quiet
    print_success "Dependencies installed"
}

cmd_monitor() {
    print_header "BLE Monitor"
    check_venv
    "$VENV_PYTHON" "$BLE_TOOL" debug "$@"
}


cmd_clean() {
    print_header "Cleaning Build Artifacts"
    check_venv
    cd "$PROJECT_DIR"
    # Use PlatformIO from the project venv to avoid global `pio` differences
    "$VENV_PYTHON" -m platformio run --target clean
    rm -rf "$PROJECT_DIR/.pio/build"
    print_success "Build artifacts cleaned"
}

# Main command dispatcher
case "${1:-}" in
    "build")
        cmd_build "${@:2}"
        ;;
    "flash")
        cmd_flash "${@:2}"
        ;;
    "upload")
        cmd_upload "${@:2}"
        ;;
    "build-upload")
        cmd_build_upload "${@:2}"
        ;;
    "export")
        cmd_export "${@:2}"
        ;;
    "analyze" | "analyse")
        cmd_analyze "${@:2}"
        ;;
    "report")
        cmd_report "${@:2}"
        ;;
    "analyze-offline" | "analyse-offline")
        cmd_analyze_offline "${@:2}"
        ;;
    "scan")
        cmd_scan "${@:2}"
        ;;
    "connect")
        cmd_connect "${@:2}"
        ;;
    "debug")
        cmd_debug "${@:2}"
        ;;
    "info")
        cmd_info "${@:2}"
        ;;
    "install")
        cmd_install "${@:2}"
        ;;
    "monitor")
        cmd_monitor "${@:2}"
        ;;
    "clean")
        cmd_clean "${@:2}"
        ;;
    "--help" | "-h" | "help" | "")
        show_usage
        ;;
    *)
        print_error "Unknown command: $1"
        echo ""
        show_usage
        exit 1
        ;;
esac
